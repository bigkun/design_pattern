## 结构型设计模式
1. Adapter
2. Bridge
3. Composite
4. Decorator
5. Facade
6. Flyweight
7. Proxy

### 1. 适配器模式
Adapter模式也称作Wrapper模式。现有代码无法直接使用，经过一定的转换或包装之后就能够使用的模式成为适配器模式。
将现有接口转换为客户类所期望的接口，实现了对现有类的复用。

> 将两个不兼容的类结合在一起使用，属于结构型模式，需要有Adaptee和Adapter两个角色。


Adapter模式中的概念：
1. Target: 目标，负责定义需要的方法
2. Adaptee: 被适配对象，已经存在一个或一些可以工作的方法，但并不直接符合Target要求，需要经过一定的转换才能满足要求。
3. Adapter: 适配对象，将Adaptee转换为Target

Adapter模式有两种：
* 类适配器模式（使用继承 is-a）
* 对象适配器模式（使用委托/组合 has-a）

Java并不支持多重类继承，因此类适配器模式会有些受限，比如Target不是接口，而是类；或者Adapter不是可继承（final）。所以java
中对象适配器模式使用的多一些。

何时使用Adapter模式：
1. 复用现有代码，但需要稍作调整时：
使用Adapter模式可以在完全不改变现有代码的前提下使现有代码适配于新的接口。
2. 版本升级与兼容：

### 2. 桥接模式
如果存在两个或以上独立变化的维度，只依赖继承，会让子类繁多、继承层次加深，增加代码复杂度。通过使用桥接模式，使得各个维度独立扩展，最后动态进行组合。

桥接模式将抽象部分和实现部分分离，使它们可以独立地变化。

桥接模式角色：
1. Abstraction(抽象类): 用于定义抽象类的接口，一般是抽象类而不是接口.保存Implementor实例，并借由Implementor实现功能
2. RefinedAbstraction(改善后的抽象类): 在Abstraction的基础上增加新功能。
3. Implementor(实现者): 定义实现接口，接口不一定完全与Abstraction接口一致，Implementor接口仅提供最基本的操作，而Abstraction接口可能会做更多更复杂的操作。
4. ConcreteImplementor(具体实现者): 实现Implementor定义的接口。


![](https://gitee.com/bigkun/design_pattern/raw/master/structural/bridge.png)

> RefinedAbstraction 可以横向扩展，ConcreteImplementor也可以横向扩展，使用时动态的组合两者。

### 3. 组合模式
可能使用树形结构模式更容易理解，或者称之为容器模式。此模式的关键词：容器、递归。

Composite定义:将对象以树形结构组织起来，以达到“部分-整体”的层次结果，使得客户端对单个对象和组合对象的使用具有一致性。

Composite模式中的概念：
1. Leaf(树叶):  叶子节点，没有子节点。
2. Composite(组合物): 容器节点，可以包含子容器或叶子节点。
3. Component(组件): 节点的抽象类或接口，定义了节点的共性行为。


组合模式还可以细分为：
* 透明组合模式：容器特性由抽象节点（Component）定义，叶子节点会继承容器相关方法。
* 安全组合模式：Component只定义业务相关方法，容器相关方法由容器节点定义，这样叶子节点不会因为继承而具有容器方法，保证运行期安全。

### 4. 装饰模式
装饰模式可以在不改变对象本身功能的基础上给对象增加额外的新行为。例如一块蛋糕，不改变蛋糕本身，加上奶油就是奶油蛋糕，加上草莓，就是草莓奶油蛋糕，插上蜡烛，就是生日蛋糕。

Decorator模式中的概念：
1. Component(抽象组件): 基类，原始对象，被装饰者。 具体组件和抽象装饰类的父类。
2. ConcreteComponent(具体组件): 
3. Decorator(装饰物):与Component具有相同的接口
4. ConcreteDecorator(具体的装饰物)

> java.io 包使用了大量的装饰模式

#### 适用场景
1. 在不影响其他对象的情况下，动态、透明地为单个对象添加职责
2. 当不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时可以使用装饰模式。不能采用继承的情况主要有两类：
    1. 系统中存在大量独立的扩展，为支持每一种扩展或扩展之间的组合将产生大量的子类。
    2. 类不能被继承（final class）
> 缺点是会产生很多功能类似的小类。

### 5. 外观模式
外观模式也称之为门面模式，是一种使用频率很高的结构型设计模式。通过引入一个外观角色来简化客户端与子系统之间的交互，为复杂的子系统提供一个统一的入口，
降低了子系统与客户端的耦合度，且客户端调用方便。

外观模式是**迪米特法则**的一种具体实现。

Facade是一个源自法语的单词，意思是“建筑物的正面”。

![](https://gitee.com/bigkun/design_pattern/raw/master/structural/facade.png)

外观模式中，一个子系统的外部与其内部的通信通过一个统一的外观类进行，外观类将客户类与子系统的内部复杂性分隔开，使得客户类只需要与外观角色打交道，
而不需要与子系统内部的很多对象打交道。

Facade模式概念：
1. Facade: 向系统外部提供高层接口
2. SubSystem(子系统): 实现各种功能的子系统，它们并不知道Facade角色

> JDBC和Slf4j都是门面模式的应用